// Code generated by ragel -Z -G2 lex.rl. DO NOT EDIT.

package flatlang

import "fmt"

%%{

machine expr;

prepush { if nostack() { return }; }

Space    = [ \t\r\n]+;
Comment1 = "//" [^\r\n]*;
Comment2 = "/*" any* :>> "*/";

Int      = [0-9]+;
Float    = (([1-9] [0-9]* [.] [0-9]*) | (0? [.] [0-9]+)) ([Ee] [+\-]? [0-9]+)?;
Bool     = "true"|"false";
Ident    = ([a-zA-Z] [a-zA-Z0-9_]*) - Bool;

string := |*
    ['] => {
        if !tokleave('\'') {
            return
        };
        fret;
    };

    ( [^'\\] | /\\./ )+ => {
        tok(text);
        addLines()
    };
*|;

rstring := |*
    ["] => {
        if !tokleave('"') {
            return
        };
        fret;
    };

    ( [^"\\] | /\\./ )+ => {
        tok(text);
        addLines()
    };
*|;

qstring := |*
    [`] => {
        if !tokleave('`') {
            return
        };
        fret;
    };

    "${" => {
        tokenter(interp, '}');
        fcall expr;
    };

    ( [^$`\\] | /[$][^{`]/ | /\\./ )+ => {
        tok(text);
        addLines()
    };

    "$" => { tok(text) };
*|;

expr := |*

Space;
"\n"     => { r.file.AddLine(ts) };

Comment1 => { tokcomment(comment) };
Comment2 => { tokcomment(comment); addLines() };

Ident    => { tok(ident) };
Bool     => { tok(bool_)  };
Int      => { tok(int_) };
Float    => { tok(float) };

"<="  => { tok(lte) };
">="  => { tok(gte) };

['] => { tokenter('\'', '\''); fcall string; };
["] => { tokenter('"', '"'); fcall rstring; };
[`] => { tokenter('`', '`'); fcall qstring; };

"${"   => { tokenter(interp, '}'); fcall expr; };
"(" => { tokenter('(', ')'); fcall expr; };
"[" => { tokenter('[', ']'); fcall expr; };
"{" => { tokenter('{', '}'); fcall expr; };
[}\])] => { if !tokleave(int(data[ts])) { return }; fret; };

any => { tok(int(data[ts])) };

*|;

}%%

%% write data;

func lexData(data []byte, r *Lexer) (err error) {
	var cs, act, ts, te, top int
	var stack [64]int
	p, pe := 0, len(data)
	eof := pe
%% write init;
	_, _, _, _, _, _ = expr_first_final, expr_error, expr_en_string, expr_en_rstring, expr_en_qstring, expr_en_expr
	if r.file == nil {
		r.file = fileset.AddFile("(string)", -1, len(data))
	}
	r.Data = data
	nostack := func() bool {
		if top != len(stack) {
			return false
		}
		err = r.Errorf("exceeds recursion limit")
		return true
	}

	var backrefs Stack

	tok := func(sym int) { r.Tokens = append(r.Tokens, Token{Sym: sym, Pos: ts, End: te}) }
	tokcomment := func(sym int) { r.Comments = append(r.Comments, Token{Sym: sym, Pos: ts, End: te}) }
	tokenter := func(sym, fin int) { backrefs.Push(len(r.Tokens), fin); tok(sym); }
	tokleave := func(sym int) bool {
		tok(sym)
		if top == 0 || len(backrefs) == 0 {
			err = r.Errorf("does not close anything")
			return false
		}
		iprev, prevsym := backrefs.Pop()
		if prevsym != sym {
			err = r.Errorf("does not close %v", r.Tokens[iprev])
			return false
		}
		r.Tokens[len(r.Tokens)-1].Prev = iprev
		return true
	}
	addLines := func() {
		for i := ts; i < te; i++ {
			if data[i] == '\n' {
				r.file.AddLine(i)
			}
		}
	}

%% write exec;

	if p != eof {
		err = r.Errorf("precedes the token that failed to lex")
	} else if len(backrefs) != 0 {
		iprev, _ := backrefs.Pop()
		prev := r.Tokens[iprev]
		err = fmt.Errorf("%s%s is not terminated", r.At(prev.Pos), Repr(prev.Sym))
	}
	return
}